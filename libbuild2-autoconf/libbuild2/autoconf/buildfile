intf_libs = # Interface dependencies.
impl_libs = # Implementation dependencies.

import impl_libs += build2%lib{build2} # Implied interface dependency.
import impl_libs += build2%lib{build2-in}

lib{build2-autoconf}: {hxx ixx txx cxx}{* -checks} {hxx cxx}{checks} \
                      $impl_libs $intf_libs

# - File name must be the exact variable name plus .h (used for sorting).
# - First line in the file should be `// <NAME> [<MODIFIER>] [:<BASE>...]`.
# - No double-quote or backslash escaping except for line continuations.
#
# NOTE: remember to update README.md if changing anything here.
#
<{hxx cxx}{checks}>: checks/file{*.h}
{
  install = false
  backlink = true
}
{{
  diag gen ($>[1])

  # We have to sort without the extension.
  #
  i = $regex.apply($sort($base($path($<))), '(.+)', '\1.h')

  h = $path($>[0])
  s = $path($>[1])

  # We regularize the output with a dummy start entry plus add five end
  # dummies that are used in tests.
  #
  n = $size($<)
  n += 6

  cat <<"EOI" >$h
  namespace build2
  {
    namespace autoconf
    {
      struct check
      {
        const char* name;
        const char* modifier; // ! or empty
        const char* base;     // base names or empty
        const char* value;
      };

      extern const check checks[$n];
    }
  }
  EOI

  cat <<"EOI" >$s
  #include <libbuild2/autoconf/checks.hxx>

  const build2::autoconf::check build2::autoconf::checks[$n] = {
  {
  \"\", \"\", \"\",

  \"\"
  EOI

  cat $i | sed -n \
    -e 's|^// ([^ !:]+) *(!)? *(: *(( *[^ ]+)+))? *$|},\n\n{\n"\1", "\2", "\4",\n|p' \
    -e 's|^(.*)\\$|"\1\\\\\\n"|p' \
    -e 's|^(.*)$|"\1\\n"|p' \
    - >>$s

  cat <<EOI >>$s
  },

  {
  "zzz_TEST_DUMMY1_H", "", "",

  "#define zzz_TEST_DUMMY1_H 1\n"
  },

  {
  "zzz_TEST_DUMMY2_H", "", "",

  "#define zzz_TEST_DUMMY2_H 1\n"
  },

  {
  "zzz_TEST_DUMMY3_H", "!", "",

  "#define zzz_TEST_DUMMY3_H 1\n"
  },

  {
  "zzz_TEST_DUMMY4_H", "", "zzz_TEST_DUMMY1_H zzz_TEST_DUMMY3_H",

  "#ifdef zzz_TEST_DUMMY1_H\n"
  "#  define zzz_TEST_DUMMY4_H zzz_TEST_DUMMY3_H\n"
  "#endif /*zzz_TEST_DUMMY1_H*/\n"
  },

  {
  "zzz_TEST_DUMMY5_H", "", "zzz_TEST_DUMMY3_H zzz_TEST_DUMMY4_H",

  "#ifdef zzz_TEST_DUMMY3_H\n"
  "#  define zzz_TEST_DUMMY5_H zzz_TEST_DUMMY4_H\n"
  "#endif /*zzz_TEST_DUMMY3_H*/\n"
  }
  };
  EOI
}}

# Build options.
#
cxx.poptions =+ "-I$out_root" "-I$src_root"

obja{*}: cxx.poptions += -DLIBBUILD2_AUTOCONF_STATIC_BUILD
objs{*}: cxx.poptions += -DLIBBUILD2_AUTOCONF_SHARED_BUILD

# Export options.
#
lib{build2-autoconf}:
{
  cxx.export.poptions = "-I$out_root" "-I$src_root"
  cxx.export.libs = $intf_libs
}

liba{build2-autoconf}: cxx.export.poptions += -DLIBBUILD2_AUTOCONF_STATIC
libs{build2-autoconf}: cxx.export.poptions += -DLIBBUILD2_AUTOCONF_SHARED

# For pre-releases use the complete version to make sure they cannot be used
# in place of another pre-release or the final version. See the version module
# for details on the version.* variable values.
#
if $version.pre_release
  lib{build2-autoconf}: bin.lib.version = "-$version.project_id"
else
  lib{build2-autoconf}: bin.lib.version = "-$version.major.$version.minor"

# Embed the build system core version as our load suffix.
#
libs{build2-autoconf}: bin.lib.load_suffix = "-$build.version.interface"

# Install into the libbuild2/autoconf/ subdirectory of, say, /usr/include/
# recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/libbuild2/autoconf/
  install.subdirs = true
}
